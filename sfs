#!/bin/bash
# -------------------------------------------------------------------------------------------
# sfs - s.earch f.ile s.ize and create a pastebin of the results
# sfs Version: 1.0
# Github: https://github.com/InterGenStudios/sfs
# ---------------------------------------------------
# InterGenStudios: 5-3-15
# Copyright (c) 2015: Christopher 'InterGen' Cork  InterGenStudios
# URL: https://intergenstudios.com
# --------------------------------
# License: GPL-2.0+
# URL: http://opensource.org/licenses/gpl-license.php
# ---------------------------------------------------
# sfs is free software:
# You may redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software
# Foundation, either version 2 of the License, or (at your discretion)
# any later version.
# ------------------

#############################################
##-----------------------------------------##
## BEGIN - MAKE SURE WE'RE RUNNING AS ROOT ##
##-----------------------------------------##
#############################################

if [ "$(id -u)" != "0" ]; then
    tput bold
    tput setaf 1
    printf "\n\n"
    echo "--------"
    echo "WARNING!"
    echo "--------"
    echo
    tput sgr0
    echo "sfs must be run as root!"
    echo "(Exiting now...)"
    printf "\n\n"
    exit 1
fi

###########################################
##---------------------------------------##
## END - MAKE SURE WE'RE RUNNING AS ROOT ##
##---------------------------------------##
###########################################

###########################################
##---------------------------------------##
## BEGIN - INITIAL VARIABLE DECLARATIONS ##
##---------------------------------------##
###########################################

# Sets sfs version number
vers=1.0

# Simple regex for number checking
RE='^[0-9]+$'

# Sets timestamp
stamp="$(echo $(date +"%m-%d-%Y") $(date +"%T"))"

#########################################
##-------------------------------------##
## END - INITIAL VARIABLE DECLARATIONS ##
##-------------------------------------##
#########################################

#######################
##-------------------##
## BEGIN - FUNCTIONS ##
##-------------------##
#######################

# Colors trailing text Red
RED () {
tput bold
tput setaf 1
}

# Colors trailing text Green
GREEN () {
tput bold
tput setaf 2
}

# Colors trailing text Yellow
YELLOW () {
tput bold
tput setaf 3
}

# Colors trailing text Blue
BLUE () {
tput bold
tput setaf 4
}

# Removes any previously set colors
WHITE () {
tput sgr0
}

# A simple divider
SEPARATOR () {
BLUE
echo
echo "-----------------------------------------------------------------------------------"
echo
WHITE
}

# Creates uniform look during script execution when called after any clear command
HEADER () {
echo
BLUE
echo "============================================================================"
WHITE
echo "  sfs v$vers"
BLUE
echo "============================================================================"
WHITE
printf "\n\n"
}

HELPTEXT () {
clear
HEADER
GREEN
echo "sfs help:"
echo
echo "SFS is a simple cPanel server utility for finding files of a target size"
echo "and pastebinning the results."
echo
WHITE
echo "------------------"
echo
GREEN
echo "USAGE:"
echo
WHITE
echo "sfs [domain_name] [target_file_size] || [domain_name] || -h (runs helptext)"
printf "\n\n"
exit 0
}

GET_TARGET_FILESIZE () {
clear
HEADER
GREEN
printf "In MB, what size of files are we looking for? "
WHITE
echo -n "[Default = 100]: "
read TARGETSIZE
if [ -z "$TARGETSIZE" ]; then
    SIZE=100
    sleep 1
elif ! [[ $TARGETSIZE =~ $RE ]]; then
    echo
    echo "Hey Sparky, \"$TARGETSIZE\" isn't a number-size in MB-- let's run it again, shall we?"
    sleep 2
    GET_TARGET_FILESIZE
else
    SIZE=$TARGETSIZE
    sleep 1
fi
}

LOOP () {
    echo
    echo "Hey Sparky, \"$CHOICE\" isn't a valid path on this server."
    echo
    sleep 1
    echo "Double check the path you're trying to search, and let's run it again- shall we?"
    SEPARATOR
    GET_TARGET_FILESIZE
}

SEARCH () {
# Default search size
SEARCHSIZE=$(($SIZE * 1000))
tput cuu 2 && tput el
GREEN
printf "Server: "
WHITE
echo "$HOSTNAME $stamp"
SEPARATOR
GREEN
printf "Searching recursively in "
WHITE
printf "%s" "$TARGET_DIR"
GREEN
printf " for files >= "
WHITE
printf "%s" "$SIZE"
GREEN
echo "M"
SEPARATOR
find "$TARGET_DIR" -type f -size +"$SEARCHSIZE"k -exec ls -lh {} \; 2>/dev/null | awk '{ printf "%- 130s %s\n", $9,$5; }'
printf "\n\n"
GREEN
printf "Total Size of "
WHITE
printf "%s" "$TARGET_DIR"
GREEN
printf ": "
WHITE
echo "$DIR_SIZE"
COUNT_FILES
echo "Search complete"
SEPARATOR
printf "\n\n"
}

PASTE () {
PASTEFILE=$@;
curl -d name=sfs -d private=1 --data-urlencode text@$PASTEFILE -s http://nobits.ml/api/create > TEMPASTE
sed -i 's/view/view\/raw/g' TEMPASTE
SEPARATOR
GREEN
printf "Your results are at "
WHITE
echo "$(cat TEMPASTE)"
echo
GREEN
echo "Your paste will expire in 30 days"
SEPARATOR
rm -rf TEMPASTE
}

GET_FILECOUNTER_CHOICE () {
clear
HEADER
GREEN
echo "While we're looking, should we find the total number of files"
WHITE
echo "                                        (including subdirectories)"
GREEN
printf "                                                    in your chosen directory "
WHITE
echo -n "(y/N)? "
read FILE_COUNTER
}

# Checks for FILESEARCH flag
CHECK_FILECOUNTER_CHOICE () {
if [ -z "$FILE_COUNTER" ] || [ "$FILE_COUNTER" = N ] || [ "$FILE_COUNTER" = n ]; then
    FILECOUNTER=NO
    echo
    YELLOW
    echo "Filecounter skipped"
    WHITE
    echo
    echo "Getting total directory size..."
elif [[ $FILE_COUNTER =~ $RE ]]; then
    echo
    YELLOW
    echo "I ask for 'y' or 'N', and you enter a number... How does that even work?"
    SEPARATOR
    sleep 1
    YELLOW
    echo "It doesn't, actually."
    sleep 1
    RED
    echo "Restarting..."
    WHITE
    sleep 2
    GET_TARGET_FILESIZE
else
    FILECOUNTER=YES
    echo
    GREEN
    echo "Filecounter enabled"
    WHITE
    echo
    echo "Getting total directory size..."
fi
}

# Counts # of files if target directory
COUNT_FILES () {
    if [ "$FILECOUNTER" = YES ]; then
        TOTAL_FILE_COUNT="$(echo $(($(du -ah "$TARGET_DIR" 2>/dev/null | wc -l) - 1)))"
        echo
        GREEN
        printf "Total number of files in "
        WHITE
        printf "%s" "$TARGET_DIR"
        GREEN
        printf ": "
        WHITE
        echo "$TOTAL_FILE_COUNT"
        echo
    fi
}

CHECK_TARGET_DIR_EXISTS () {
if [ ! -d "$TARGET_DIR" ]; then
    LOOP
fi
}

GET_TARGET_DIR () {
clear
HEADER
GREEN
printf "Enter target path we're going to search recursively for files >= "
WHITE
printf "%s" "$SIZE"
GREEN
echo "M,"
echo "or choose from the following directories:"
echo
WHITE
printf "1) "
GREEN
echo "User Directories"
WHITE
printf "2) "
GREEN
echo "/var/log Directory"
WHITE
printf "3) "
GREEN
echo "cPanel Logs Directory"
WHITE
printf "4) "
GREEN
echo "MySQL Directory"
WHITE
printf "5) "
GREEN
echo "cPanel Backup Directory"
echo
WHITE
printf "("
GREEN
printf "default "
WHITE
printf "= "
GREEN
printf "Root Directory"
WHITE
echo ")"
echo
WHITE
echo -n "[enter choice or directory path]:"
read DIR_CHOICE
case $DIR_CHOICE in
          1) TARGET_DIR=/home;;
          2) TARGET_DIR=/var/log;;
          3) TARGET_DIR=/usr/local/cpanel/logs;;
          4) TARGET_DIR=/var/lib/mysql;;
          5) TARGET_DIR=/backup;;
          *) if [ -z "$DIR_CHOICE" ]; then
                TARGET_DIR=/
             elif ! [[ $DIR_CHOICE =~ $RE ]]; then
                TARGET_DIR=$DIR_CHOICE
             fi;;
esac
}

GET_INPUT () {
GET_TARGET_FILESIZE
GET_TARGET_DIR
GET_FILECOUNTER_CHOICE
CHECK_FILECOUNTER_CHOICE
}

#####################
##-----------------##
## END - FUNCTIONS ##
##-----------------##
#####################

#########################
##---------------------##
## BEGIN - CORE SCRIPT ##
##---------------------##
#########################

if [ $1 = -h ]; then
    HELPTEXT
else
    if [ -z $1 ]; then
        GET_INPUT
    else
        if [ -d $1 ] && [[ $2 =~ $RE ]]; then
            TARGET_DIR=$1
            SIZE=$2
            GET_FILECOUNTER_CHOICE
            CHECK_FILECOUNTER_CHOICE
        elif [ -d $1 ] && [ -z $2 ]; then
            TARGET_DIR=$1
            GET_TARGET_FILESIZE
            GET_FILECOUNTER_CHOICE
            CHECK_FILECOUNTER_CHOICE
        fi
    fi
fi
CHECK_TARGET_DIR_EXISTS
DIR_SIZE="$(du -h $TARGET_DIR 2>/dev/null | tail -1 | awk '{print $1}')"
mkdir -p /root/support
clear
HEADER
SEARCH 2>&1 | tee searchfile
sed -i -e 's/[\x01-\x1F\x7F]//g' -e 's|\[1m\[32m||g' -e 's|(B\[m||g' -e 's|\[1m\[34m||g' -e 's|\[2A\[K||g' searchfile
PASTE searchfile
rm -rf searchfile
printf "\n\n"
exit 0

#######################
##-------------------##
## END - CORE SCRIPT ##
##-------------------##
#######################
